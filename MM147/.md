## MM147 参加記

MM147に参加していました。システムテストはまだですが2位に8ptほど差をつけているので恐らく優勝です。


#### 問題概要
- ay+bx
- sin(ay)+cos(bx)
- y xor x
- exp(-ay-bx)

これらの関数に平行移動と係数をランダムに適用されたものが2\~30個たされた後、0\~255の整数値に正規化されたN*Nのグリッドがある。(20<=N<=60)
一回のクエリでクエリの位置を中心とした3*3領域の値がわかるので頑張って推定しろ。
スコアは`A*MSE+(1-A)*クエリの回数`でこれの最小化。
入力としてグリッドサイズNとスコア関数のパラメータAが与えられる。


#### 解法
###### 大枠
UNetを用いて推定します。  
入力はクエリの結果を最近傍補間したものと、どこがクエリの結果として帰ってきたかのbitmapの2ch画像として、直接推定結果を学習します。  
学習用の画像はテスターと同じ方法で生成し、クエリの回数は`randint(N^2/150,N^2/50)`としてランダムな位置のクエリをやったものを使いました。

20\*20から60\*60の入力がありますが、セル単位の予測がしたいので24\*24から64\*64の8刻み全てで学習し、60\*60であれば64\*64のモデルを用い、リサイズはせず外側に4マスあると思ってUNetで推定します。


次にクエリのいちの決定ですが、これは各々のクエリの位置が全ていい感じに離れていると良いです。簡単には格子点の位置などを用いれば良いですが、これではクエリの回数が平方数である場合しか実現できません。そこでCircle packing in a squareの結果を埋め込むことでクエリの回数を1単位で調整可能にしました。
参考： [http://www.packomania.com/](http://www.packomania.com/)

そして入力で与えられるN,Aからクエリの回数を決めるようにします。

これだけで順位表の80点に到達できます。

##### 細かな工夫
各々1~2%程効きます。

- クエリにより少なくとも正しいとわかっている場所はその値にする。その周辺も微調整する。
- packomaniから埋め込んだ位置を原点中心に拡大して少し壁際に寄せる
- クエリの順番は`y+x`が小さい順にして、クエリの半分が終わった時点で階差の分散が閾値以下であれば、まだクエリを終えていない頂点からランダムに数個消し、残った頂点の位置を山登りで微調整する
- Eが少なくapply_xy2のみで構成されていると推定される場合はその場合のみで訓練されたモデルを用いる（判定は何らかの3*3の領域すべての要素が1以下であればという感じにする）
- 1000ケースでパラメータを調整


###### だめだったこと
- Xorの性質から位置xに崖が存在するときx+8,x+16にも崖が発生しやすいです。そのためUNetの一部に全結合層を噛ませて縦方向の縞模様、横方向の縞模様を作ったりしたのですが、特に良くならず。
- 問題の性質上必ず画像の中に0,255が含まれるのですが、UNetの推定結果がけっこうチキってしまう問題が発生した、が、人力でちょっと調整するくらいでは良くならないのでUNetがスコアが最大化できる値にしてくれているのだろうと信じることにした。
- 極値をクエリで叩けば推定結果が良くなるのかなとか思いましたが規則的に取ったほうが良かった。

#### 感想
自分のPCに機械学習のモジュールを入れるのが面倒だったのでColaboratoryをずっと使ってた。そこまで快適ではなかったけど少なくとも自分のPCよりは学習が速くなったので、はい。  
GPUを使えないからGPUの使い方とか知らないけど流石に勉強したほうが良さそう。CPU、遅すぎ  
提出してもほとんど他の人の点数を削れなかった。
