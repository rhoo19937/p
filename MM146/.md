# Marathon Match 146 参加記


### 問題
https://www.topcoder.com/challenges/9e14555a-a853-4137-8902-cd118f7ea5dc?tab=details  
この参加記では N=グリッドのサイズ K=連結成分のサイズ C=カラー数 としています。

<br>

### 解法
コンテスト中の自分の解法は97.0%で4位で、コンテスト後に目標盤面の作り方を乱択貪欲から焼きなましに変更したことによってスコアが3.4%ほど上がりました。これは優勝するのに十分なスコアなのですが、残念。  
ここではコンテスト中に使用した乱択貪欲とコンテスト後の焼きなまし、そして目標盤面へ揃える解法を解説します。  

<br>

##### 最初の考察
ピースの作成ボーナスが最小でもK*4得られる。つまり1セルごとに平均4回未満で揃えていけば元はとれる。実際は目標盤面と近いピースを作成していくことになるのでこれは簡単に達成でき、ほとんどのケースの最適解はできるだけ多くのピースを作っているということが考えらる。    
まず最初に考えられる方針としては、与えられた盤面を直接動かしてピースを作っていくというものがあるが、これはピースの作成コストは抑えられますが、盤面全体をピースで埋め尽くすような解を見つけることは難しいため、この問題ではうまく動きそうない。  
ですが、まず最初に与えられた盤面から近い目標盤面を作るフェーズと与えられた盤面を目標盤面に揃えるフェーズとすれば上手く行く気がします。  
ということで最終的な解法は2つのフェーズに分けて実行するようにした。 

<br>

##### 乱択貪欲で目標盤面を作る
コンテスト中に自分が実装した解法。  
まず始点をランダムに選択してそこからの距離が短いセル順に決定していく。  
ピースが作成不可能だとわかったらそのセルは一回飛ばして最後に埋める。  
ピースの作成方法は選んだ色をcとすると以下のルールベースで作成。    
- 隣接している未確定のセルをランダムに選ぶ
- ただし、隣接している中にc以外の色を置くと他の作成済みのピースに影響が出てしまうならそのピースを最優先で埋める
- この操作をK回行う
- K回操作が終わった時点で隣接している中にc以外の色を置くと他の作成済みのピースに影響が出てしまうものがあるなら作成不可能とする  

この操作を1~Cの色ごとにランダムに10回繰り返し、評価関数が一番良かったものを選択。  

評価関数  
`0.6*揃えるコスト+0.9*無駄になった領域+グリッドを埋める難易度`  

- 揃えるコスト
	-  あるセルから色がcの近い順にK個のセルの距離の平均
	-  これをピースに含まれるセル全てで計算した総和
- 無駄になった領域
	- そのピースを置いたことによってK個未満の領域に分断されたセルの個数
- グリッドを埋める難易度
	- あるセルが接している未確定のマスをd、確定したピースに影響がないように置ける色の数をnとすると`d/4*n/C`
	- これを未確定のセル全てで計算した総和  

最後にタイブレークとして一番残っている数が多い色を優先。  
評価関数は差分だけを計算することによってO(K)。  
  
その後ピースの色を焼きなましで変えていい感じに  
焼きなましの評価関数は乱択貪欲の揃えるコストと同じものを使用。  
近傍は単純に2つの別の色のピースの色を他のピースに影響がないように交換するだけ。  

色々頑張ってはいますが、後述の普通に焼き鈍した方針のほうが良かった。(悲しい)  


<br>

##### 焼きなましで目標盤面を作る
ほぼsimanさんの焼きなましと同じ。  
https://simanman.hatenablog.com/entry/2023/06/23/074504  
変更点  
- 終盤になるとピースのサイズのスコア対するボーナス、ペナルティをなくす。
-  ピースの移動距離の係数を-0.2から-0.6へ時間経過で変える

自分の解法だとこれらを加えると若干良くなった。  

<br>

##### ルールベースで揃える
ビームサーチの方針も考えたが、遷移候補がN^2個ある&状態の重複が多いということで厳しそうな気がしてルールベースを頑張ることにした。  

1. 割当てを決める
	- そのセルが可能な色のセル全てに対して辺をはる
		- ピースを構成するセルであればピースの色、違うのであれば周りのピースを邪魔しない色すべて
	- セルaからセルbへの辺のコストはaからbへの最短距離^1.5
		- 焼きなましの評価もこれにしてみたけど悪くなったのでボツ
	- LibraryCheckerから窃盗したnetworksimplexを用いると最大ケースでも5msかからずに計算可能(ヤバ過ぎ)
2. 無駄そうなものを削除
	- そのピースを揃えるコスト*0.6>=P/Kとなったらそのピースの作成を諦める
3. 再度割当てを決める
4. 始点を選ぶ
	- グリッドの頂点4つと辺の中点4つに一番近いものを最初に選ぶ
	- 時間が余ったら時間いっぱいまでまだ選んだことのない始点をランダムに選ぶ
5. 始点から遠いものから順に揃える
	1. みんなが目的地に近づくような経路をダイクストラで探索
	    - セルaをセルbへ移動させたいとき、まずセルbからセルaに到達するまでダイクストラで最短距離を計算
		    - ダイクストラの辺のコストは セルp->セルnp で`1.3+セルpがセルnpへ移動することによる目的のマスへの距離の移動量`
	    - その後ダイクストラで到達したすべてのセルのうち、そのセルがすでに揃っているセルでなく、かつ選んだセルとそのセルが目的地を交換しても最終的に作れるピースの数が変わらないものであるセルについて、交換によるスコアが最小になるものを選択して交換
		- (0,4)よりも(2,2)のほうが(0,0)に到達しやすいみたいな移動の自由度も評価したいが、壁がある場合にどのように計算すればいいのか分からなかったのでUDLRの計算順を毎回シャッフルすることで対応
	2. 経路上でswap可能なものがあればそれを挿入
		- ダイクストラパートではすでに揃っているものはswapの候補に含めないが、経路に含まれるのは許容しているためこれを入れる必要がある
	3. どかす操作を貪欲に挿入
		- 経路上にあるセルで目的地に近づかないようなセルは経路外にどかす操作を適当な閾値で制御して貪欲に挿入
	4. 2手playoutする
	    - ここまでの操作を現在選んでいるセルaと、セルaの付近でまだ揃えていない始点からの距離が一番遠いセルbについて、a->bの順とb->aの順で揃える場合をどちらもplayoutし、`全マスの目的地への距離の改善量の総和/操作量`がより良い方を選択  
	    - これによって交通の要所のセルが 揃える->ずらされる->揃える と無駄な動きをしてしまうことを抑制できる

<br>

### 結果
example(乱択貪欲ver)  

Score = 357.0<br>
Score = 7366.0<br>
Score = 6293.0<br>
Score = 3594.0<br>
Score = 5494.0<br>
Score = 1552.0<br>
Score = 4184.0<br>
Score = 1451.0<br>
Score = 2782.0<br>
Score = 1004.0<br>

example(焼きなましver)  

Score = 375.0<br>
Score = 7600.0<br>
Score = 6404.0<br>
Score = 3751.0<br>
Score = 5484.0<br>
Score = 1674.0<br>
Score = 4264.0<br>
Score = 1535.0<br>
Score = 2848.0<br>
Score = 1087.0<br>

焼きなましverでの出力  
seed=2  
score=7600  
7手ごと  
![vis.gif](vis.gif)

<br>


### 反省とかやってないこととか
コンテスト最初に問題がかなり入力されるパラメータで変わるのでそれに応じて使用するハイパーパラメータも変えたほうが良さそうな気がしたが、結局やらなかった。あまり敏感なパラメータはなかったが、揃えるパートは最大でも1秒未満で終わるのでそこだけにしぼって色々やったほうが良かったかもしれない。  

目標盤面に揃えるフェーズで3つ以上のswapを考えると良くなるケースがありそうだったが、実装する時間がなかったのでやっない。  
